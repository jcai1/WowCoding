{
  d = {
    actions = {
      init = {
        custom = "local t = GetTime()\nlocal A = aura_env\nlocal F = WeakAuras.regions[A.id].region\n\n-- Set constants here\nA.nrow = 5\nA.font = \"Fonts\\\\FRIZQT__.TTF\"\nA.headerHeightRel = 0.09\nA.headerLengthLimit = 25\nA.nameHeightRel = 0.25\nA.nameLengthLimit = 5\nA.borderThicknessRel = 0.03\n\n-- Creation of UI objects (done once per /reload)\nF:SetFrameLevel(0) -- level 0\nF.super = F.super or CreateFrame(\"Frame\", nil, F)\nF.super:SetFrameLevel(3) -- level 3\nF.bg = F.bg or F:CreateTexture(nil, \"BACKGROUND\", nil, 0)\nF.header = F.header or F.super:CreateFontString(nil, \"BACKGROUND\")\n-- F.headerAG = F.headerAG or F.header:CreateAnimationGroup()\n-- F.headerTrans = F.headerTrans or F.headerAG:CreateAnimation(\"Translation\")\n-- F.headerAlpha = F.headerAlpha or F.headerAG:CreateAnimation(\"Alpha\")\nF.tiles = F.tiles or {}\nF.icons = F.icons or {}\nF.cdFrames = F.cdFrames or {}\nF.cds = F.cds or {}\nF.names = F.names or {}\nF.borders = F.borders or {}\nfor i = 1, 40 do\n    F.tiles[i] = F.tiles[i] or CreateFrame(\"Frame\", nil, F) -- level 1\n    local tile = F.tiles[i]\n    F.icons[i] = F.icons[i] or tile:CreateTexture(nil, \"BACKGROUND\", nil, 2)\n    F.cdFrames[i] = F.cdFrames[i] or CreateFrame(\"Cooldown\", nil, tile, \"CooldownFrameTemplate\") -- level 2\n    F.cds[i] = F.cds[i] or F.super:CreateFontString(nil, \"BACKGROUND\")\n    F.names[i] = F.names[i] or F.super:CreateFontString(nil, \"BACKGROUND\")\n    F.borders[i] = F.borders[i] or tile:CreateTexture(nil, \"BACKGROUND\", nil, 1)\nend\n\n-- General purpose functions\nfunction A.error(msg)\n    print(\"RaidInterrupts error: \" .. msg)\nend\nfunction A.fatalError(msg)\n    print(\"RaidInterrupts fatal error: \" .. msg)\n    A.aborted = true\nend\n\nlocal function deepcopy(orig)\n    local orig_type = type(orig)\n    local copy\n    if orig_type == 'table' then\n        copy = {}\n        for orig_key, orig_value in next, orig, nil do\n            copy[deepcopy(orig_key)] = deepcopy(orig_value)\n        end\n        setmetatable(copy, deepcopy(getmetatable(orig)))\n    else -- number, string, boolean, etc\n        copy = orig\n    end\n    return copy\nend\nA.deepcopy = deepcopy\n\nfunction A.formatTime(secs)\n    if secs < 0 then\n        return \"-\" .. A.formatTime(-secs)\n    end\n    if secs < 0.5 then\n        return \"\"\n    elseif secs < 59.5 then\n        return string.format(\"%.f\", secs)\n    elseif secs < 3570 then\n        return string.format(\"%.f\", secs / 60) .. \"m\"\n    elseif secs < 84600 then\n        return string.format(\"%.f\", secs / 3600) .. \"h\"\n    elseif secs < 8631360 then\n        return string.format(\"%.f\", secs / 86400) .. \"d\"\n    else\n        return \"(!)\"\n    end\nend\n\nfunction A.scaleText(fontString)\n    local fs = fontString\n    local wmax, hmax = fs.maxWidth, fs.maxHeight\n    if not (wmax and hmax) then\n        A.error(\"scaleText called on a plain FontString\")\n    else\n        local text, w, h = fs:GetText(), fs:GetSize()\n        if w == 0 or h == 0 then return end\n        local goodness = math.max(w / wmax, h / hmax)\n        if text ~= fs.oldText or math.abs(goodness - 1) > 0.06 then\n            local prop = w / h\n            local hnew = math.floor(hmax * prop <= wmax and hmax or wmax / prop)\n            local fontName, _, flags = fs:GetFont()\n            if hnew > 32 then\n                fs:SetFont(fontName, 32, flags)\n                fs:SetTextHeight(hnew)\n            else\n                fs:SetFont(fontName, hnew, flags)\n            end\n            fs.oldText = text\n        end\n    end\nend\n\n-- Display initialization\nA.headerMsg = \"\"\nA.headerMsgTime = -math.huge\ndo\n    local square = \"Interface\\\\AddOns\\\\WeakAuras\\\\Media\\\\Textures\\\\Square_White\"\n    local left, bottom, width, height = F:GetRect()\n    local headerHeight = height * A.headerHeightRel\n    local w0, w1, w2, h0, h1, h2, h3, h4\n    h0 = height * (1 - A.headerHeightRel) / A.nrow\n    w0 = width / math.ceil(20 / A.nrow)\n    w1 = w0 * A.borderThicknessRel\n    w2 = w0 - 2 * w1\n    h1 = h0 * A.nameHeightRel\n    h2 = h0 - h1\n    h3 = h0 * A.borderThicknessRel\n    h4 = h2 - 2 * h3\n    \n    local super, bg, header = F.super, F.bg, F.header\n    bg:ClearAllPoints()\n    bg:SetPoint(\"LEFT\", F, \"LEFT\", 0, 0) -- later width will dynamically change\n    bg:SetSize(F:GetSize())\n    bg:SetTexture(square)\n    bg:SetVertexColor(0, 0, 0)\n    header:ClearAllPoints()\n    header:SetFont(A.font, 32, \"OUTLINE\")\n    header:SetPoint(\"CENTER\", F, \"TOP\", 0, -(headerHeight / 2))\n    header.maxWidth = width\n    header.maxHeight = headerHeight\n    \n    for i = 1, 40 do\n        local col = math.ceil(i / A.nrow)\n        local row = i - A.nrow * (col - 1)\n        local tile, icon, cdFrame, cd, name, border\n        = F.tiles[i], F.icons[i], F.cdFrames[i], F.cds[i], F.names[i], F.borders[i]\n        tile:ClearAllPoints()\n        tile:SetPoint(\"TOPLEFT\", F, \"TOPLEFT\", (col - 1) * w0, -((row - 1) * h0 + headerHeight))\n        tile:SetSize(w0, h0)\n        icon:ClearAllPoints()\n        icon:SetPoint(\"BOTTOM\", tile, \"BOTTOM\", 0, h3)\n        icon:SetSize(w2, h4)\n        cdFrame:ClearAllPoints()\n        cdFrame:SetAllPoints(icon)\n        cdFrame:SetHideCountdownNumbers(true) -- hide Blizzard cd text\n        cdFrame.noCooldownCount = true -- tells other addons to hide cd text\n        cd:ClearAllPoints()\n        cd:SetPoint(\"CENTER\", tile, \"BOTTOM\", 0, h2 / 2)\n        cd:SetFont(A.font, 32, \"OUTLINE\")\n        cd.maxWidth = w2\n        cd.maxHeight = h4\n        cd:SetText(\"59m\")\n        A.scaleText(cd)\n        cd:SetText(\"\")\n        name:ClearAllPoints()\n        name:SetPoint(\"CENTER\", tile, \"TOP\", 0, -h1 / 2)\n        name:SetFont(A.font, 32, \"OUTLINE\")\n        name.maxWidth = w0\n        name.maxHeight = h1\n        border:ClearAllPoints()\n        border:SetPoint(\"BOTTOM\", tile, \"BOTTOM\", 0, 0)\n        border:SetSize(w0, h2)\n        border:SetTexture(square)\n        border:Hide()\n    end\nend\n\n-- Core initialization\nA.players = {}\nA.petMap = {} -- pet GUID -> player GUID\n\nlocal unitDB = {none = {\"player\"},\n    party = {\"player\", \"party1\", \"party2\", \"party3\", \"party4\"},\n    raid = {}}\nfor i = 1, 40 do unitDB.raid[i] = \"raid\" .. i end\nA.unitDB = unitDB\nfunction A.getUnitList()\n    if IsInRaid() then\n        return A.unitDB.raid\n    elseif IsInGroup() then\n        return A.unitDB.party\n    else\n        return A.unitDB.none\n    end\nend\n\nA.intDB = { -- Baseline\n    WARRIOR = {{spell = \"Pummel\", cd = 15, icon = \"INV_Gauntlets_04\", on = true},\n        {spell = \"Heroic Throw\", cd = 15, icon = \"INV_Axe_66\"}},\n    PALADIN = {{spell = \"Rebuke\", cd = 15, icon = \"spell_holy_rebuke\", on = true},\n        {spell = \"Avenger's Shield\", cd = 15, icon = \"Spell_Holy_AvengersShield\"}},\n    HUNTER = {{spell = \"Counter Shot\", cd = 24, icon = \"inv_ammo_arrow_03\", on = true}},\n    ROGUE = {{spell = \"Kick\", cd = 15, icon = \"Ability_Kick\", on = true}},\n    PRIEST = {{spell = \"Silence\", cd = 45, icon = \"ability_priest_silence\", on = true}},\n    DEATHKNIGHT = {{spell = \"Mind Freeze\", cd = 15, icon = \"Spell_DeathKnight_MindFreeze\", on = true},\n        {spell = \"Strangulate\", cd = 60, icon = \"Spell_Shadow_SoulLeech_3\", on = true},\n        {spell = \"Asphyxiate\", cd = 30, icon = \"ability_deathknight_asphixiate\"}},\n    SHAMAN = {{spell = \"Wind Shear\", cd = 12, icon = \"Spell_Nature_Cyclone\", on = true}},\n    MAGE = {{spell = \"Counterspell\", cd = 24, icon = \"Spell_Frost_IceShock\", on = true}},\n    WARLOCK = {{spellID = 132409, spell = \"Spell Lock\", cd = 24, icon = \"Spell_Shadow_MindRot\", on = true}, -- GoSac version\n        {spellID = 119910, spell = \"Spell Lock\", cd = 24, icon = \"Spell_Shadow_MindRot\"},\n        {spell = \"Optical Blast\", cd = 24, icon = \"spell_nature_elementalprecision_1\"},\n        {spell = \"Shadow Lock\", cd = 24, icon = \"Spell_Shadow_PainAndSuffering\"}},\n    DRUID = {{spell = \"Skull Bash\", cd = 15, icon = \"inv_bone_skull_04\"},\n        {spell = \"Solar Beam\", cd = 60, icon = \"ability_vehicle_sonicshockwave\"},\n        {spell = \"Faerie Fire\", cd = 15, icon = \"spell_nature_faeriefire\"}},\n    MONK = {{spell = \"Spear Hand Strike\", cd = 15, icon = \"ability_monk_spearhand\", on = true}}\n}\n\n-- Sanity check for A.intDB\nfor class, ints in pairs(A.intDB) do\n    for k = 1, #ints do\n        local int = ints[k]\n        if not (int.spell or int.spellID) then\n            A.fatalError(class .. \" interrupt entry has no spell name/ID\")\n        else\n            local name = int.spell or int.spellID\n            if not int.cd then\n                A.fatalError(class .. \" interrupt '\" .. name .. \"' missing CD info\")\n            elseif not int.icon then\n                A.fatalError(class .. \" interrupt '\" .. name .. \"' missing icon info\")\n            end\n        end\n    end\nend\nif A.aborted then\n    return\nend\n\nA.ProtPallySpells = {[\"Avenger's Shield\"] = true, [\"Shield of the Righteous\"] = true, [\"Grand Crusader\"] = true}\nA.HolyPriestSpells = {[\"Renew\"] = true, [\"Circle of Healing\"] = true, [\"Holy Word: Serenity\"] = true, [\"Binding Heal\"] = true}\nA.BalanceDruidSpells = {[\"Starfire\"] = true, [\"Starsurge\"] = true, [\"Starfall\"] = true}\nA.MeleeDruidSpells = {[\"Lacerate\"] = true, [\"Maul\"] = true, [\"Mangle\"] = true, [\"Thrash\"] = true, [\"Savage Defense\"] = true,\n    [\"Rake\"] = true, [\"Rip\"] = true, [\"Tiger's Fury\"] = true}\n\nfunction A.lookup(ints, spellID, spell, mustBeOn) -- Lookup a spellID/spell pair in the given interrupt table\n    for k = 1, #ints do\n        local int = ints[k]\n        if (not mustBeOn or int.on)\n        and ((not int.spellID) or (not spellID) or (int.spellID == spellID))\n        and ((not int.spell) or (not spell) or (int.spell == spell)) then\n            return int\n        end\n    end\n    return nil\nend\n\nlocal function updateAllUnits()\n    -- Raid status refresh run every 0.5 seconds\n    local unitList = A.getUnitList()\n    \n    for i = 1, #unitList do\n        local u = unitList[i]\n        local pet = u .. \"pet\"\n        local guid, name, class\n        if UnitExists(u) then\n            guid = UnitGUID(u)\n            name = UnitName(u)\n            class = select(2, UnitClass(u))\n        end\n        if guid and name and class then\n            A.players[guid] = A.players[guid] or {}\n            local p = A.players[guid]\n            \n            p.unit = u\n            p.name = name\n            p.class = class\n            p.lastSeen = p.lastSeen or -math.huge\n            p.dead = UnitIsDeadOrGhost(u)\n            if UnitExists(pet) then\n                p.pet = UnitCreatureFamily(pet)\n                A.petMap[UnitGUID(pet)] = guid\n            else\n                p.pet = nil\n            end\n            p.lastPet = p.pet or p.lastPet\n            if UnitIsDeadOrGhost(pet) then\n                p.pet = nil\n            end\n            p.ints = p.ints or deepcopy(A.intDB[p.class])\n            \n            local oldCombat = p.inCombat\n            p.inCombat = UnitAffectingCombat(u)\n            if p.inCombat and not oldCombat then -- Unit entered combat\n                -- Reset their interrupt table to default, keeping the last cast time\n                local ints, newInts = p.ints, deepcopy(A.intDB[p.class])\n                for k1 = 1, #ints do\n                    for k2 = 1, #newInts do\n                        local int, newInt = ints[k1], newInts[k2]\n                        if int.spell == newInt.spell and int.spellID == newInt.spellID then\n                            newInt.lastCast = int.lastCast\n                        end\n                    end\n                end\n                p.ints = newInts\n                p.seen = (t - p.lastSeen < 10) -- Reset their seen status\n            end\n            \n            local function getInt(self, spell)\n                local int\n                if type(spell) == \"string\" then\n                    int = A.lookup(self.ints, nil, spell, false)\n                elseif type(spell) == \"number\" then\n                    int = A.lookup(self.ints, spell, nil, false)\n                end\n                if not int then\n                    A.error(\"Interrupt '\"..tostring(spell)..\"' not found\")\n                end\n                return int\n            end\n            p.getInt = getInt -- Usage: p:getInt(\"spell\") or p:getInt(spellID)\n            \n            if p.class == \"WARLOCK\" then\n                p.gosac = UnitBuff(u, \"Grimoire of Sacrifice\")\n                local spellLockSac, spellLock, opticalBlast, shadowLock\n                \n                for k = 1, #(p.ints) do\n                    local int = p.ints[k]\n                    if int.spellID == 132409 then spellLockSac = int\n                    elseif int.spellID == 119910 then spellLock = int\n                    elseif int.spell == \"Optical Blast\" then opticalBlast = int\n                    elseif int.spell == \"Shadow Lock\" then shadowLock = int\n                    end\n                end\n                if spellLockSac and spellLock and opticalBlast and shadowLock then\n                    spellLockSac.on = (p.gosac and p.lastPet == \"Felhunter\")\n                    spellLock.on = (p.pet == \"Felhunter\")\n                    opticalBlast.on = (p.pet == \"Observer\")\n                    shadowLock.on = (p.pet == \"Doomguard\" or p.pet == \"Terrorguard\")\n                    if spellLockSac.on and spellLock.lastCast\n                    and ((not spellLockSac.lastCast) or spellLock.lastCast > spellLockSac.lastCast) then\n                        spellLockSac.lastCast = spellLock.lastCast\n                    end\n                end\n            end\n        end\n    end\nend\n\nlocal function updateDisplay()\n    -- Display refresh run every 0.1 seconds\n    local t = GetTime()\n    local scaleText = A.scaleText\n    -- do\n    -- local header = F.header\n    -- header:SetText(A.headerMsg)\n    -- local delta = t - A.headerMsgTime\n    -- local alpha = (delta < 10) and (1 - delta / 10) ^ 2 or 0\n    -- header:SetTextColor(1, 1, 1, alpha)\n    -- header:SetTextColor(1, 1, 1, 1)\n    -- scaleText(header)\n    -- end\n    local rightmostPoint = 0\n    local unitList = A.getUnitList()\n    local usedTiles = {}\n    for j = 1, #unitList do\n        local u = unitList[j]\n        local p = UnitExists(u) and A.players[UnitGUID(u)]\n        local i = j -- i = display index; j = index in unitList\n        local show\n        if p then\n            local inCombat = UnitAffectingCombat(\"player\")\n            if inCombat then\n                show = p.seen and not p.dead\n            else\n                show = UnitIsVisible(p.unit)\n            end\n        end\n        \n        local tile, name, icon, cd, cdFrame, border\n        = F.tiles[i], F.names[i], F.icons[i], F.cds[i], F.cdFrames[i], F.borders[i]\n        \n        if show then\n            usedTiles[i] = true\n            rightmostPoint = math.max(rightmostPoint, tile:GetRight())\n            \n            do\n                name:SetText(string.sub(p.name, 1, A.nameLengthLimit))\n                local c = RAID_CLASS_COLORS[p.class]\n                name:SetTextColor(c.r, c.g, c.b)\n                scaleText(name)\n                name:Show()\n            end\n            \n            local count, charges, minRecharge, iconName = 0, 0, math.huge, nil\n            local intWithMinRecharge\n            \n            for k = 1, #(p.ints) do\n                local int = p.ints[k]\n                if int.on then\n                    count = count + 1\n                    local elapsed = t - (int.lastCast or -math.huge)\n                    local remain = math.max(0, int.cd - elapsed)\n                    if remain == 0 then\n                        if charges == 0 then\n                            iconName = int.icon\n                        end\n                        charges = charges + 1\n                    elseif remain < minRecharge then\n                        minRecharge = remain\n                        intWithMinRecharge = int\n                        iconName = int.icon\n                    end\n                end\n            end\n            if count > 0 then\n                icon:SetTexture(\"Interface\\\\Icons\\\\\" .. iconName)\n                icon:Show()\n                if minRecharge < math.huge then\n                    cd:SetText(A.formatTime(minRecharge))\n                    cdFrame:SetCooldown(intWithMinRecharge.lastCast, intWithMinRecharge.cd)\n                    if charges > 0 then\n                        cd:SetTextColor(0, 1, 1, 1)\n                    else\n                        if minRecharge < 5.5 then\n                            cd:SetTextColor(1, 0, 0, 1)\n                        elseif minRecharge < 59.5 then\n                            cd:SetTextColor(1, 1, 0, 1)\n                        else\n                            cd:SetTextColor(1, 1, 1, 1)\n                        end\n                    end\n                    cd:Show()\n                    cdFrame:Show()\n                else\n                    cd:Hide()\n                    cdFrame:Hide()\n                end\n                if charges >= 1 then\n                    border:SetVertexColor(1, 1, 1)\n                else\n                    border:SetVertexColor(0, 0, 0)\n                end\n                border:Show()\n            else\n                icon:Hide()\n                cd:Hide()\n                cdFrame:Hide()\n                border:Hide()\n            end\n        end\n    end\n    for i = 1, 40 do\n        local name, icon, cd, cdFrame, border\n        = F.names[i], F.icons[i], F.cds[i], F.cdFrames[i], F.borders[i]\n        if not usedTiles[i] then\n            name:Hide()\n            icon:Hide()\n            cd:Hide()\n            cdFrame:Hide()\n            border:Hide()\n        end\n    end\n    F.bg:SetWidth(math.max(F:GetWidth(), rightmostPoint - F.bg:GetLeft()))\nend\n\nA.periodic = {} -- Array of periodic callbacks. Entry = {interval = ..., callback = ...}\ntable.insert(A.periodic, {interval = 0.1, callback = updateDisplay})\ntable.insert(A.periodic, {interval = 0.5, callback = updateAllUnits})",
        do_custom = true
      }
    },
    activeTriggerMode = 0,
    additional_triggers = {
      {
        trigger = {
          event = "Conditions",
          subeventPrefix = "SPELL",
          subeventSuffix = "_CAST_START",
          type = "status",
          unevent = "auto",
          unit = "player",
          use_alwaystrue = true,
          use_unit = true
        },
        untrigger = {}
      }
    },
    color = {
      [4] = 0
    },
    customText = "-- Custom text\nfunction()\n    local t = GetTime()\n    local A = aura_env\n    local F = WeakAuras.regions[A.id].region\n    \n    if A.aborted then\n        return\n    end\n    \n    for k = 1, #(A.periodic) do\n        local val = A.periodic[k]\n        val.lastCalled = val.lastCalled or -math.huge\n        if t - val.lastCalled > val.interval then\n            val.callback()\n            val.lastCalled = t\n        end\n    end\nend",
    desc = "Arc v0.0 2015-11-18",
    disjunctive = "any",
    displayStacks = "%c",
    displayText = "%c",
    height = 269.99996948242199,
    id = "Raid Interrupts",
    init_completed = 1,
    justify = "LEFT",
    load = {
      difficulty = {
        multi = {}
      },
      faction = {
        multi = {}
      },
      pvptalent = {
        multi = {}
      },
      race = {
        multi = {}
      },
      role = {
        multi = {}
      },
      talent = {
        multi = {}
      },
      use_never = true,
      use_petbattle = false
    },
    numTriggers = 2,
    outline = true,
    regionType = "icon",
    trigger = {
      custom = "-- Trigger: COMBAT_LOG_EVENT_UNFILTERED\nfunction(_, _, subEvent, _, sourceGUID, sourceName, _, _, destGUID, destName, _, _, ...)\n    local t = GetTime()\n    local A = aura_env\n    if A.aborted then\n        return\n    end\n    \n    local p, p2 = A.players[sourceGUID], A.players[destGUID]\n    \n    if p then\n        p.seen = true\n        p.lastSeen = t\n    end\n    if p2 then\n        p2.seen = true\n        p2.lastSeen = t\n    end\n    \n    if not p and subEvent == \"SPELL_INTERRUPT\" and sourceGUID:sub(1, 3) == \"Pet\" then\n        -- Pretend the master is the source\n        sourceGUID = A.petMap[sourceGUID]\n        if sourceGUID then\n            p = A.players[sourceGUID]\n            sourceName = p.name\n        end\n    end\n    \n    if not p then\n        return\n    end\n    \n    local class = p.class\n    \n    if subEvent == \"SPELL_CAST_SUCCESS\" then\n        local spellID, spell = ...\n        \n        if class == \"PALADIN\" then\n            -- If pally casts prot-only spell, we know they can cast Avenger's Shield.\n            if A.ProtPallySpells[spell] then\n                p:getInt(\"Avenger's Shield\").on = true\n            end\n        elseif class == \"ROGUE\" then\n            -- If the spell is Kick, and the last Kick happened < 15 seconds ago, it's glyphed.\n            if spell == \"Kick\" then\n                local int = p:getInt(\"Kick\")\n                local castDelta = t - (int.lastCast or -math.huge)\n                if castDelta < 14.8 then\n                    int.glyphed = true -- cue more special processing\n                end\n                if int.glyphed then\n                    int.cd = 19 -- reduced to 13 if we see a successful Kick\n                end\n            end\n        elseif class == \"PRIEST\" then\n            if A.HolyPriestSpells[spell] then\n                p:getInt(\"Silence\").on = false\n            end\n            if spell == \"Silence\" then\n                local int = p:getInt(\"Silence\")\n                local castDelta = t - (int.lastCast or -math.huge)\n                if castDelta < 44.5 then\n                    int.cd = 25\n                end\n            end\n        elseif class == \"DEATHKNIGHT\" then\n            if spell == \"Strangulate\" or spell == \"Asphyxiate\" then\n                local int1, int2 = p:getInt(\"Strangulate\"), p:getInt(\"Asphyxiate\")\n                int1.on = (spell == \"Strangulate\")\n                int2.on = (not int1.on)\n            end\n            if spell == \"Mind Freeze\" then\n                local int = p:getInt(\"Mind Freeze\")\n                local castDelta = t - (int.lastCast or -math.huge)\n                if castDelta < 14.8 then\n                    int.cd = 14\n                end\n            end\n        elseif class == \"MAGE\" then\n            -- If mage is casting/channeling when Counterspell is used, it's glyphed.\n            if spell == \"Counterspell\" then\n                local int = p:getInt(\"Counterspell\")\n                if int.cd == 24 and UnitExists(p.unit) and (UnitCastingInfo(p.unit) or UnitChannelInfo(p.unit)) then\n                    int.cd = 28\n                end\n            end\n        elseif class == \"WARLOCK\" then\n            if spellID == 132409 then\n                p.lastPet = \"Felhunter\"\n            end\n        elseif class == \"DRUID\" then\n            if A.BalanceDruidSpells[spell] then\n                p:getInt(\"Solar Beam\").on = true\n            elseif A.MeleeDruidSpells[spell] then\n                p:getInt(\"Skull Bash\").on = true\n            end\n        end\n        \n        local int = A.lookup(p.ints, spellID, spell, false)\n        if int then\n            int.lastCast = t\n        else\n        end\n    elseif subEvent == \"SPELL_INTERRUPT\" then\n        local spellID, spell = ...\n        local class = p.class\n        \n        if class == \"ROGUE\" then\n            if spell == \"Kick\" then\n                local int = p:getInt(\"Kick\")\n                if int.glyphed then\n                    int.cd = 13\n                end\n            end\n        end\n        \n        local int = A.lookup(p.ints, spellID, spell, false)\n        if int then\n            int.on = true -- If spell was used to interrupt, it must be on\n            int.lastInt = t\n        else\n            --A.error(\"Unknown interrupt '\"..spell..\"' (\"..spellID..\") occurred\")\n        end\n        \n        do\n            local extraSpellName = select(5, ...)\n            local s1, s2, len, limit = sourceName, extraSpellName, string.len, A.headerLengthLimit\n            local iter = 0\n            while len(s1) + 1 + len(s2) > limit do\n                iter = iter + 1\n                if iter == 1 then\n                    s1 = s1:sub(1, A.nameLengthLimit)\n                elseif iter == 2 then\n                    local s = \"\"\n                    for tok in s2:gmatch(\"%S+\") do\n                        s = s .. tok:gsub(\"^%l\", string.upper)\n                    end\n                    s2 = s\n                else\n                    s2 = s2:sub(1, limit - (len(s1) + 1))\n                    break\n                end\n            end\n            local F = WeakAuras.regions[A.id].region\n            local header = F.header\n            local c = RAID_CLASS_COLORS[class]\n            header:SetText(string.format(\"|c%s%s|r>%s\", c.colorStr, s1, s2))\n            A.scaleText(header)\n        end\n    end\nend",
      custom_hide = "timed",
      custom_type = "event",
      events = "COMBAT_LOG_EVENT_UNFILTERED",
      type = "custom"
    },
    width = 163.00030517578099,
    xOffset = 555.999755859375,
    yOffset = -404.99948120117199
  },
  m = "d",
  s = "2.2.1.1",
  v = 1421
}
