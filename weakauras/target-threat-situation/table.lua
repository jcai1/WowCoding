{
  d = {
    actions = {
      init = {
        custom = "---- BEGIN OPTIONS ----\n\n-- The sound to use for the audio alert.\nlocal alertSound = \"Sound\\\\SPELLS\\\\SPELL_DR_Artifact_MoonSpells_ImpactLight_02.ogg\"\n\n-- Mutes the audio alert if you are not using a tank spec.\nlocal muteIfNotTanking = true\n\n-- Disables the WeakAura entirely (audio + text) if you are not using a tank spec.\nlocal disableIfNotTanking = false\n\n-- Disables the text display (but not the audio alert) regardsless of your role.\nlocal disableTextDisplay = false\n\n-- How often to scan the raid for general player info.\nlocal raidRefreshInterval = 0.5\n\n-- How often to scan the raid for threat.\nlocal refreshInterval = 0.1\n\n-- How often to play the alert sound (if enabled).\nlocal audioInterval = 2\n\n-- The role icons on the text display.\nlocal roleIconNone = \"Interface\\\\Icons\\\\inv_misc_questionmark\"\nlocal roleIconTank = \"Interface\\\\Icons\\\\spell_holy_devotionaura\"\nlocal roleIconHealer = \"Interface\\\\Icons\\\\spell_nature_resistnature\"\nlocal roleIconDamager = \"Interface\\\\Icons\\\\ability_warrior_punishingblow\"\n\n-- List of NPCs for which to hide the threat table and disable the audio alert\n-- You can include either the NPC name or the NPC id\nlocal npcBlacklist = {\n}\n-- List of NPCs for which to disable the audio alert only\nlocal npcAudioBlacklist = {\n}\n\n---- END OPTIONS ----\n\nlocal A = aura_env\nlocal customText = \"\"\nlocal audioOn = false\n\nlocal function makeTextureString(icon)\n    -- The preceding space is necessary or the alignment gets fucked\n    return \" |T\" .. icon .. \":12|t\"\nend\n\nlocal roleIconStrings = {\n    [\"NONE\"] = makeTextureString(roleIconNone),\n    [\"TANK\"] = makeTextureString(roleIconTank),\n    [\"HEALER\"] = makeTextureString(roleIconHealer),\n    [\"DAMAGER\"] = makeTextureString(roleIconDamager)\n}\n\nlocal npcBlacklistTest = {}\nfor _, v in ipairs(npcBlacklist) do\n    npcBlacklistTest[v] = true\nend\n\nlocal npcAudioBlacklistTest = {}\nfor _, v in ipairs(npcAudioBlacklist) do\n    npcAudioBlacklistTest[v] = true\nend\n\n-- Returns \"BOTH\", \"AUDIO\", or \"NONE\" based on blacklist status\nlocal function npcBlacklistStatus(npcName, npcId)\n    if npcBlacklistTest[npcName] or npcBlacklistTest[npcId] then\n        return \"BOTH\"\n    elseif npcAudioBlacklistTest[npcName] or npcAudioBlacklistTest[npcId] then\n        return \"AUDIO\"\n    else\n        return \"NONE\"\n    end\nend\n\n-- Key: unit GUID\n-- Value: table with the following keys:\n--     If not isPet: unit, name, role (all guaranteed); class, pet (optional)\n--     If isPet: unit, owner, ownerRole, family (all guaranteed)\nlocal players = {}\n\n-- Entry: { player = <entry in players>, threat = <raw threat> }\n-- [1] = <primary target>\n-- [2] = <highest tank>\n-- [3] = <highest non-tank>\n-- [4] = <player>\nlocal threatTbl = {{}, {}, {}, {}}\n\nlocal lines = {}\n\nlocal unitDB = {\n    none = {\"player\"},\n    party = {\"player\", \"party1\", \"party2\", \"party3\", \"party4\"},\n    raid = {}\n}\nfor i = 1, 40 do unitDB.raid[i] = \"raid\" .. i end\n\nlocal function resetThreatTbl(threatTbl)\n    for i = 1, 4 do\n        threatTbl[i].player = nil\n        threatTbl[i].threat = -1\n        threatTbl[i].alert = nil\n    end\nend\n\nlocal function cmpThreat(a, b)\n    return a.threat > b.threat\nend\n\nlocal function sortThreatTbl(threatTbl)\n    sort(threatTbl, cmpThreat)\nend\n\nlocal function getUnitList()\n    if IsInRaid() then\n        return unitDB.raid\n    elseif IsInGroup() then\n        return unitDB.party\n    else\n        return unitDB.none\n    end\nend\n\nlocal function getPlayerSpecRole()\n    local playerSpec = GetSpecialization()\n    return playerSpec and select(6, GetSpecializationInfo(playerSpec)) or \"NONE\"\nend\n\nlocal function refreshRaid()\n    local playerSpecRole = getPlayerSpecRole()\n    if playerSpecRole ~= \"TANK\" then\n        if disableIfNotTanking or (disableTextDisplay and muteIfNotTanking) then\n            return\n        end\n    end\n    \n    local unitList = getUnitList()\n    \n    for i = 1, #unitList do\n        local u = unitList[i]\n        local upet = u .. \"pet\"\n        local _, guid, name, class, role\n        if UnitExists(u) then\n            guid = UnitGUID(u)\n            name = UnitName(u)\n            _, class = UnitClass(u)\n            role = UnitGroupRolesAssigned(u)\n        end\n        if guid and name and role then\n            players[guid] = players[guid] or {}\n            local p = players[guid]\n            p.unit = u\n            p.name = name\n            p.class = class\n            p.role = role\n            -- p.dead = UnitIsDeadOrGhost(u)\n            p.isPet = false\n            \n            if UnitExists(upet) then\n                local petGUID = UnitGUID(upet)\n                players[petGUID] = players[petGUID] or {}\n                local pet = players[petGUID]\n                pet.isPet = true\n                pet.unit = upet\n                pet.owner = guid\n                pet.ownerRole = role\n                pet.family = UnitCreatureFamily(upet) or \"Pet\"\n                \n                p.pet = petGUID\n            else\n                p.pet = nil\n            end\n            \n            -- p.inCombat = UnitAffectingCombat(u)\n        end\n    end\nend\n\nlocal function guidToNpcId(guid)\n    if not guid then\n        return\n    end\n    local n = strlen(guid)\n    if strsub(guid, 1, 8) ~= \"Creature\" then\n        return\n    end\n    local lastHyphen, penultHyphen\n    for i = n, 1, -1 do\n        if strsub(guid, i, i) == \"-\" then\n            lastHyphen = i\n            break\n        end\n    end\n    if lastHyphen then\n        for i = (lastHyphen - 1), 1, -1 do\n            if strsub(guid, i, i) == \"-\" then\n                penultHyphen = i\n                break\n            end\n        end\n        if penultHyphen then\n            return tonumber(strsub(guid, penultHyphen + 1, lastHyphen - 1))\n        end\n    end\nend\n\nlocal function getRoleOrOwnerRole(p)\n    if p then\n        return p.isPet and p.ownerRole or p.role\n    end\nend\n\nlocal function playerToString(p)\n    if p.isPet then\n        return playerToString(players[p.owner]) .. \"'s \" .. p.family\n    else\n        local classColorCode = p.class and RAID_CLASS_COLORS[p.class].colorStr or \"ff888888\"\n        return \"|c\" .. classColorCode .. p.name .. \"|r\"\n    end\nend\n\nlocal function colorIfTruthy(text, cond, trueColor)\n    if cond then\n        return \"|cff\" .. trueColor .. text .. \"|r\"\n    else\n        return text\n    end\nend\n\nlocal healerOrDamagerTest = {\n    [\"HEALER\"] = true,\n    [\"DAMAGER\"] = true\n}\n\nlocal usedPlayers = {}\nlocal function refresh()\n    customText = \"\"\n    audioOn = false\n    \n    if WeakAuras.IsOptionsOpen() then\n        customText = \"Target Threat Situation\"\n        return\n    end\n    \n    local playerSpecRole = getPlayerSpecRole()\n    if playerSpecRole ~= \"TANK\" then\n        if disableIfNotTanking or (disableTextDisplay and muteIfNotTanking) then\n            return\n        end\n    end\n    \n    local targetGUID = UnitGUID(\"target\")\n    local targetNpcId = targetGUID and guidToNpcId(targetGUID)\n    local targetName = UnitName(\"target\")\n    if not targetNpcId and targetName then\n        return\n    end\n    \n    local blacklistStatus = npcBlacklistStatus(targetName, targetNpcId)\n    if blacklistStatus == \"BOTH\" then\n        return\n    end\n    \n    if not (UnitCanAttack(\"player\", \"target\") and UnitCanAttack(\"target\", \"player\")) then\n        return\n    end\n    \n    local unitList = getUnitList()\n    local tankThreat = 0\n    local tt = threatTbl\n    resetThreatTbl(tt)\n    \n    for i = 1, #unitList do\n        local u = unitList[i]\n        local upet = u .. \"pet\"\n        local p, pet\n        if UnitExists(u) then\n            p = players[UnitGUID(u)]\n        end\n        if UnitExists(upet) then\n            pet = players[UnitGUID(upet)]\n        end\n        \n        if p then\n            local isTanking, _, _, _, threat = UnitDetailedThreatSituation(u, \"target\")\n            if isTanking then\n                tt[1].player = p\n                tt[1].threat = threat or 0\n                tankThreat = threat or 0\n            end\n            if threat then\n                if p.role == \"TANK\" then\n                    if threat > tt[2].threat then\n                        tt[2].player = p\n                        tt[2].threat = threat\n                    end\n                else\n                    if threat > tt[3].threat then\n                        tt[3].player = p\n                        tt[3].threat = threat\n                    end\n                end\n                if UnitIsUnit(u, \"player\") then\n                    tt[4].player = p\n                    tt[4].threat = threat\n                end\n            end\n        end\n        \n        if pet then\n            local isTanking, _, _, _, threat = UnitDetailedThreatSituation(upet, \"target\")\n            if isTanking then\n                tt[1].player = pet\n                tt[1].threat = threat or 0\n                tankThreat = threat or 0\n            end\n            if threat then\n                if p.role == \"TANK\" then\n                    if threat > tt[2].threat then\n                        tt[2].player = pet\n                        tt[2].threat = threat\n                    end\n                else\n                    if threat > tt[3].threat then\n                        tt[3].player = pet\n                        tt[3].threat = threat\n                    end\n                end\n            end\n        end\n    end\n    \n    local tt1Player = tt[1].player\n    local tt3Player = tt[3].player\n    local tt1Role = tt1Player and getRoleOrOwnerRole(tt1Player)\n    local tt3Role = tt3Player and getRoleOrOwnerRole(tt3Player)\n    \n    -- Alert visually if primary target isn't a tank (or tank's pet)\n    -- Alert aurally if primary target is specifically a player with healer/DPS role (minimize annoyance / false positives)\n    if tt1Player and (tt1Role ~= \"TANK\") then\n        tt[1].alert = true\n        if healerOrDamagerTest[tt1Role] and not tt1Player.isPet then\n            audioOn = true\n        end\n        -- Alert visually if top non-tank's threat > the top tank's threat\n        -- Alert aurally if top non-tank is specifically a player with healer/DPS role\n    elseif tt3Player and (tt[3].threat > tt[2].threat) then\n        tt[3].alert = true\n        if healerOrDamagerTest[tt3Role] and not tt3Player.isPet then\n            audioOn = true\n        end\n    end\n    if playerSpecRole ~= \"TANK\" and muteIfNotTanking then\n        audioOn = false\n    end\n    \n    if not disableTextDisplay then\n        local primaryTarget = tt[1].player\n        -- Sort threat table before display, invalidating special meaning of tt[1]...tt[4]\n        sortThreatTbl(tt)\n        wipe(lines)\n        wipe(usedPlayers)\n        for i = 1, 4 do\n            local x = tt[i]\n            if x.threat == -1 then break end\n            local p = x.player\n            if p and not usedPlayers[p] then\n                usedPlayers[p] = true\n                local role = getRoleOrOwnerRole(p)\n                local threatPctStr = tankThreat > 0 and format(\"%3.f%%%%\", 100 * x.threat / tankThreat) or \"Inf%%\"\n                threatPctStr = (p == primaryTarget) and (\">\" .. threatPctStr .. \"<\") or (\" \" .. threatPctStr .. \" \")\n                lines[#lines + 1] =\n                colorIfTruthy(threatPctStr, x.alert, \"ff0000\")\n                .. roleIconStrings[role]\n                .. playerToString(p)\n            end\n        end\n        customText = table.concat(lines, \"\\n\")\n    end\nend\n\nlocal lastRaidRefresh = 0\nlocal lastRefresh = 0\nlocal lastAudio = 0\n\nfunction A.statusTrigger()\n    local now = GetTime()\n    if now - lastRaidRefresh > raidRefreshInterval then\n        lastRaidRefresh = now\n        refreshRaid()\n    end\n    if now - lastRefresh > refreshInterval then\n        lastRefresh = now\n        refresh()\n    end\n    if audioOn and now - lastAudio > audioInterval then\n        lastAudio = now\n        PlaySoundFile(alertSound, MASTER)\n    end\n    return customText ~= \"\"\nend\n\nfunction A.customTextFunc()\n    return customText\nend",
        do_custom = true
      }
    },
    activeTriggerMode = 0,
    customText = "function() return aura_env.customTextFunc() end",
    desc = "Arc v1.0 2016-11-18",
    displayText = "%c",
    font = "Fira Mono Medium",
    fontSize = 18,
    height = 18,
    id = "Target Threat Situation",
    numTriggers = 1,
    regionType = "text",
    selfPoint = "TOP",
    trigger = {
      check = "update",
      custom = "function() return aura_env.statusTrigger() end",
      custom_type = "status",
      type = "custom"
    },
    untrigger = {
      custom = "function() return true end"
    },
    width = 9,
    xOffset = 0,
    yOffset = -150
  },
  m = "d",
  s = "2.2.2.1",
  v = 1421
}
