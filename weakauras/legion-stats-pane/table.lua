{
  d = {
    actions = {
      init = {
        custom = "---- Legion Stats Pane (Init) ----\n\n-- Note that some of this stuff is copied directly from Blizzard's FrameXML,\n-- in particular PaperDollFrame.lua. If anything in here is confusing or gross,\n-- it's not my fault. OTOH, if anything in here is amazing or awesome, I take credit.\n\nlocal A = aura_env\nlocal R = WeakAuras.regions[A.id].region\nlocal S = WeakAurasSaved.displays[A.id]\n\n-- Possible anchor behaviors\n-- FIXED: Fixed position, no auto-anchor\n-- RIGHT: Anchor to right of character info frame\n-- OVERLAY: Anchor directly above default stats pane, hiding it\nlocal ANCHOR_FIXED, ANCHOR_RIGHT, ANCHOR_OVERLAY = 0, 1, 2\n\n---- Set options here ----\nlocal bgColor = {0, 0, 0, 1}    -- Background color/opacity (RGBA)\nlocal headerColor = \"33b5ff\"      -- Color for category headings\nlocal statNameColor = \"f5bc00\"    -- Color for stat names\nlocal refreshRate = 10            -- How many times per second to refresh stats\nlocal anchorBehavior = ANCHOR_OVERLAY  -- See above\n\n----- Utility -----\nlocal function printf(...) print(format(...)) end\nlocal function errorf(...) error(format(...)) end\n\n----- Stats string construction, utility -----\n\n-- Gets ranged damage or melee damage based on weapon\nlocal function GetAppropriateDamage(unit)\n    if IsRangedWeapon() then\n        local attackTime, minDamage, maxDamage, bonusPos, bonusNeg, percent = UnitRangedDamage(unit);\n        return minDamage, maxDamage, nil, nil, 0, 0, percent;\n    else\n        return UnitDamage(unit);\n    end\nend\n\n-- Gets the bonus afforded to a pet stat based on a player stat\nfunction ComputePetBonus(stat, value)\n    local _, class = UnitClass(\"player\")\n    local mult\n    if class == \"WARLOCK\" then\n        mult = WARLOCK_PET_BONUS[stat]\n    elseif class == \"HUNTER\" then\n        mult = HUNTER_PET_BONUS[stat]\n    end\n    return mult and (value * mult) or 0\nend\n\n-- Wraps text in red color string\nlocal function redFont(s)\n    return RED_FONT_COLOR_CODE .. s .. FONT_COLOR_CODE_CLOSE\nend\n\n-- Wraps text in green color string\nlocal function greenFont(s)\n    return GREEN_FONT_COLOR_CODE .. s .. FONT_COLOR_CODE_CLOSE\nend\n\n-- Idk, sorta rewrote some messy Blizzard code\nlocal function formatWithBuffs(effective, base, posBuff, negBuff)\n    local B = BreakUpLargeNumbers\n    local eff = B(effective)\n    local base = B(base)\n    local pos = greenFont(\"+\" .. B(posBuff))\n    local neg = redFont(B(negBuff))\n    if posBuff > 0 then\n        if negBuff < 0 then\n            return format(\"%s (%s%s%s)\", redFont(eff), base, pos, neg)\n        else\n            return format(\"%s (%s%s)\", greenFont(eff), base, pos)\n        end\n    else\n        if negBuff < 0 then\n            return format(\"%s (%s%s)\", redFont(eff), base, neg)\n        else\n            return eff\n        end\n    end\nend\n\n-- Common code for certain simple \"rating\" stats which all\n-- (1) use GetCombatRating and GetCombatRatingBonus directly\n-- (2) have values expressed in percentages\nfunction formatRatingStat(value, rating)\n    return format(\"%.2f%% (%s / +%.2f%%)\",\n        value,\n        BreakUpLargeNumbers(GetCombatRating(rating)),\n        GetCombatRatingBonus(rating))\nend\n\n----- Stats string construction, core -----\n\n-- Array to contain the lines of text.\nlocal lines = {}\n\n-- Add a header line\nfunction addHeader(lines, s)\n    tinsert(lines, format(\"|cff%s==== %s ====|r\", headerColor, s))\nend\n\n-- Add a line for a stat\nfunction addStat(lines, name, value)\n    tinsert(lines, format(\"|cff%s%s:|r %s\",\n            statNameColor, name, tostring(value)))\nend\n\n-- Add a line for a formatted stat\nfunction addFStat(lines, name, fmt, ...)\n    addStat(lines, name, format(fmt, ...))\nend\n\n-- Add a line for a stat using formatRatingStat\nfunction addRatingStat(lines, name, value, rating)\n    addStat(lines, name, formatRatingStat(value, rating))\nend\n\n\n-- Getters / formatters for individual stats. Each function should\n-- append to `lines` the formatted information about the new stat.\n\n-- Health\nlocal function addHealth(lines, unit)\n    local health = UnitHealthMax(unit);\n    health = BreakUpLargeNumbers(health);\n    addStat(lines, \"Health\", health)\nend\n\n-- Power and Alternate Mana\nlocal function addPower(lines, unit)\n    local powerType, powerToken = UnitPowerType(unit);\n    local power = UnitPowerMax(unit) or 0;\n    power = BreakUpLargeNumbers(power);\n    if powerToken and _G[powerToken] then\n        addStat(lines, _G[powerToken], power)\n    end\n    \n    local _, class = UnitClass(unit)\n    if class == \"DRUID\"\n    or (class == \"MONK\" and GetSpecialization() == SPEC_MONK_MISTWEAVER) then\n        if powerToken ~= \"MANA\" then\n            local mana = UnitPowerMax(unit, SPELL_POWER_MANA);\n            mana = BreakUpLargeNumbers(mana);\n            addStat(lines, \"Mana\", mana)\n        end\n    end\nend\n\n-- Item Level\nlocal function addItemLevel(lines, unit)\n    if unit ~= \"player\" then return end\n    local total, equipped, pvp = GetAverageItemLevel();\n    if total == pvp then\n        addFStat(lines, \"Item Level\", \"%d / %d\", equipped, total)\n    else\n        addFStat(lines, \"Item Level\", \"%d / %d (PvP %d)\", equipped, total, pvp)\n    end\nend\n\n-- Movement Speed\nlocal wasSwimming = nil\nlocal function addMovementSpeed(lines, unit)\n    local _, runSpeed, flightSpeed, swimSpeed = GetUnitSpeed(unit);\n    runSpeed = runSpeed/BASE_MOVEMENT_SPEED*100;\n    flightSpeed = flightSpeed/BASE_MOVEMENT_SPEED*100;\n    swimSpeed = swimSpeed/BASE_MOVEMENT_SPEED*100;\n    \n    -- Pets seem to always actually use run speed\n    if (unit == \"pet\") then\n        swimSpeed = runSpeed;\n    end\n    \n    -- Determine whether to display running, flying, or swimming speed\n    local speed = runSpeed;\n    local swimming = IsSwimming(unit);\n    if (swimming) then\n        speed = swimSpeed;\n    elseif (IsFlying(unit)) then\n        speed = flightSpeed;\n    end\n    \n    -- Hack so that your speed doesn't appear to change when jumping out of the water\n    if (IsFalling(unit)) then\n        if (wasSwimming) then\n            speed = swimSpeed;\n        end\n    else\n        wasSwimming = swimming;\n    end\n    \n    -- We'll put the actual Speed stat in the Tertiary section\n    addFStat(lines, \"Speed\", \"%.f%% (Run %.f%% Fly %.f%% Swim %.f%%)\",\n    speed, runSpeed, flightSpeed, swimSpeed)\nend\n\n-- Primary Stats\nlocal function addPrimaryStat(lines, unit, statIndex)\n    local statName = _G[\"SPELL_STAT\"..statIndex..\"_NAME\"]\n    local statValue, effectiveStat, posBuff, negBuff = UnitStat(unit, statIndex);\n    local base = statValue - posBuff - negBuff\n    addStat(lines, statName, formatWithBuffs(effectiveStat, base, posBuff, negBuff))\nend\n\n-- Critical Strike\nlocal function addCrit(lines, unit)\n    if unit ~= \"player\" then return end\n    local rating;\n    local spellCrit, rangedCrit, meleeCrit;\n    local critChance;\n    \n    -- Start at 2 to skip physical damage\n    local holySchool = 2;\n    local minCrit = GetSpellCritChance(holySchool);\n    local spellCrit;\n    for i=(holySchool+1), MAX_SPELL_SCHOOLS do\n        spellCrit = GetSpellCritChance(i);\n        minCrit = min(minCrit, spellCrit);\n    end\n    spellCrit = minCrit\n    rangedCrit = GetRangedCritChance();\n    meleeCrit = GetCritChance();\n    \n    if (spellCrit >= rangedCrit and spellCrit >= meleeCrit) then\n        critChance = spellCrit;\n        rating = CR_CRIT_SPELL;\n    elseif (rangedCrit >= meleeCrit) then\n        critChance = rangedCrit;\n        rating = CR_CRIT_RANGED;\n    else\n        critChance = meleeCrit;\n        rating = CR_CRIT_MELEE;\n    end\n    \n    if GetCritChanceProvidesParryEffect() then\n        local critRating = GetCombatRating(rating);\n        addFStat(lines, \"Crit\", \"%.2f%% (%s / +%.2f%%) (Parry +%.2f%%)\",\n            critChance,\n            BreakUpLargeNumbers(critRating),\n            GetCombatRatingBonus(rating),\n            GetCombatRatingBonusForCombatRatingValue(CR_PARRY, critRating));\n    else\n        addRatingStat(lines, \"Crit\", critChance, rating)\n    end\nend\n\n-- Haste\nlocal function addHaste(lines, unit)\n    if unit ~= \"player\" then return end\n    addRatingStat(lines, \"Haste\", GetHaste(), CR_HASTE_MELEE)\nend\n\n-- Mastery\nlocal function addMastery(lines, unit)\n    if not (unit == \"player\" and UnitLevel(\"player\") >= SHOW_MASTERY_LEVEL) then\n        return\n    end\n    local mastery, bonusCoeff = GetMasteryEffect();\n    local masteryRating = GetCombatRating(CR_MASTERY);\n    local masteryBonus = GetCombatRatingBonus(CR_MASTERY) * bonusCoeff;\n    addFStat(lines, \"Mastery\", \"%.2f%% (%s / +%.2f%%)\",\n        mastery,\n        BreakUpLargeNumbers(masteryRating),\n    masteryBonus)\nend\n\n-- Versatility\nlocal function addVersatility(lines, unit)\n    if unit ~= \"player\" then return end\n    local versatility = GetCombatRating(CR_VERSATILITY_DAMAGE_DONE);\n    local versatilityDamageBonus =\n    GetCombatRatingBonus(CR_VERSATILITY_DAMAGE_DONE)\n    + GetVersatilityBonus(CR_VERSATILITY_DAMAGE_DONE);\n    local versatilityDamageTakenReduction =\n    GetCombatRatingBonus(CR_VERSATILITY_DAMAGE_TAKEN)\n    + GetVersatilityBonus(CR_VERSATILITY_DAMAGE_TAKEN);\n    \n    addFStat(lines, \"Versatility\", \"%.2f%% (%s) (Taken -%.2f%%)\",\n        versatilityDamageBonus,\n        BreakUpLargeNumbers(versatility),\n    versatilityDamageTakenReduction)\nend\n\n-- Lifesteal (Leech)\nlocal function addLifesteal(lines, unit)\n    if unit ~= \"player\" then return end\n    addRatingStat(lines, \"Leech\", GetLifesteal(), CR_LIFESTEAL)\nend\n\n-- Avoidance\nlocal function addAvoidance(lines, unit)\n    if unit ~= \"player\" then return end\n    addRatingStat(lines, \"Avoidance\", GetAvoidance(), CR_AVOIDANCE)\nend\n\n-- Speed\nlocal function addSpeed(lines, unit)\n    if unit ~= \"player\" then return end\n    addRatingStat(lines, \"Speed\", GetSpeed(), CR_SPEED)\nend\n\n-- Attack Damage\nlocal function addAttackDamage(lines, unit)\n    local text\n    local speed, offhandSpeed = UnitAttackSpeed(unit);\n    local minDamage, maxDamage, minOffHandDamage, maxOffHandDamage,\n    physicalBonusPos, physicalBonusNeg, percent = GetAppropriateDamage(unit);\n    \n    -- remove decimal points for display values\n    local displayMin = max(floor(minDamage),1);\n    local displayMinLarge = BreakUpLargeNumbers(displayMin);\n    local displayMax = max(ceil(maxDamage),1);\n    local displayMaxLarge = BreakUpLargeNumbers(displayMax);\n    \n    -- calculate base damage\n    minDamage = (minDamage / percent) - physicalBonusPos - physicalBonusNeg;\n    maxDamage = (maxDamage / percent) - physicalBonusPos - physicalBonusNeg;\n    \n    local baseDamage = (minDamage + maxDamage) * 0.5;\n    local fullDamage = (baseDamage + physicalBonusPos + physicalBonusNeg) * percent;\n    local totalBonus = (fullDamage - baseDamage);\n    -- set tooltip text with base damage\n    local damageTooltip = BreakUpLargeNumbers(max(floor(minDamage),1))..\" - \"..BreakUpLargeNumbers(max(ceil(maxDamage),1));\n    \n    local colorPos = \"|cff20ff20\";\n    local colorNeg = \"|cffff2020\";\n    \n    -- epsilon check\n    if ( totalBonus < 0.1 and totalBonus > -0.1 ) then\n        totalBonus = 0.0;\n    end\n    \n    if ( totalBonus == 0 ) then\n        if ( ( displayMin < 100 ) and ( displayMax < 100 ) ) then \n            text = (displayMinLarge..\" - \"..displayMaxLarge);    \n        else\n            text = (displayMinLarge..\"-\"..displayMaxLarge);\n        end\n    else\n        -- set bonus color and display\n        local color;\n        if ( totalBonus > 0 ) then\n            color = colorPos;\n        else\n            color = colorNeg;\n        end\n        if ( ( displayMin < 100 ) and ( displayMax < 100 ) ) then \n            text = (color..displayMinLarge..\" - \"..displayMaxLarge..\"|r\");    \n        else\n            text = (color..displayMinLarge..\"-\"..displayMaxLarge..\"|r\");\n        end\n        if ( physicalBonusPos > 0 ) then\n            damageTooltip = damageTooltip..colorPos..\" +\"..physicalBonusPos..\"|r\";\n        end\n        if ( physicalBonusNeg < 0 ) then\n            damageTooltip = damageTooltip..colorNeg..\" \"..physicalBonusNeg..\"|r\";\n        end\n        if ( percent > 1 ) then\n            damageTooltip = damageTooltip..colorPos..\" x\"..floor(percent*100+0.5)..\"%|r\";\n        elseif ( percent < 1 ) then\n            damageTooltip = damageTooltip..colorNeg..\" x\"..floor(percent*100+0.5)..\"%|r\";\n        end\n    end\n    \n    addStat(lines, \"Damage\", text)\n    addStat(lines, \"MH Damage\", damageTooltip)\n    \n    -- If there's an offhand speed then add the offhand info to the tooltip\n    if ( offhandSpeed and minOffHandDamage and maxOffHandDamage ) then\n        minOffHandDamage = (minOffHandDamage / percent) - physicalBonusPos - physicalBonusNeg;\n        maxOffHandDamage = (maxOffHandDamage / percent) - physicalBonusPos - physicalBonusNeg;\n        \n        local offhandBaseDamage = (minOffHandDamage + maxOffHandDamage) * 0.5;\n        local offhandFullDamage = (offhandBaseDamage + physicalBonusPos + physicalBonusNeg) * percent;\n        local offhandDamageTooltip = BreakUpLargeNumbers(max(floor(minOffHandDamage),1))..\" - \"..BreakUpLargeNumbers(max(ceil(maxOffHandDamage),1));\n        if ( physicalBonusPos > 0 ) then\n            offhandDamageTooltip = offhandDamageTooltip..colorPos..\" +\"..physicalBonusPos..\"|r\";\n        end\n        if ( physicalBonusNeg < 0 ) then\n            offhandDamageTooltip = offhandDamageTooltip..colorNeg..\" \"..physicalBonusNeg..\"|r\";\n        end\n        if ( percent > 1 ) then\n            offhandDamageTooltip = offhandDamageTooltip..colorPos..\" x\"..floor(percent*100+0.5)..\"%|r\";\n        elseif ( percent < 1 ) then\n            offhandDamageTooltip = offhandDamageTooltip..colorNeg..\" x\"..floor(percent*100+0.5)..\"%|r\";\n        end\n        \n        addStat(lines, \"OH Damage\", offhandDamageTooltip)\n    end\nend\n\n-- Attack Power\nlocal function addAttackPower(lines, unit)\n    local tag;\n    local text;\n    local base, posBuff, negBuff;\n    \n    local rangedWeapon = IsRangedWeapon();\n    \n    if ( rangedWeapon ) then\n        base, posBuff, negBuff = UnitRangedAttackPower(unit);\n        tag = \"Ranged AP\"\n    else \n        base, posBuff, negBuff = UnitAttackPower(unit);\n        tag = \"Melee AP\"\n    end\n    \n    local damageBonus\n    local spellPower = 0;\n    local effectiveAP = max(0,base + posBuff + negBuff);\n    if (GetOverrideAPBySpellPower() ~= nil) then\n        local holySchool = 2;\n        -- Start at 2 to skip physical damage\n        spellPower = GetSpellBonusDamage(holySchool);        \n        for i=(holySchool+1), MAX_SPELL_SCHOOLS do\n            spellPower = min(spellPower, GetSpellBonusDamage(i));\n        end\n        spellPower = min(spellPower, GetSpellBonusHealing()) * GetOverrideAPBySpellPower();\n        \n        text = BreakUpLargeNumbers(spellPower)\n        damageBonus = BreakUpLargeNumbers(spellPower / ATTACK_POWER_MAGIC_NUMBER);\n    else\n        text = formatWithBuffs(effectiveAP, base, posBuff, negBuff)\n        damageBonus = BreakUpLargeNumbers(effectiveAP / ATTACK_POWER_MAGIC_NUMBER)\n    end\n    \n    if (GetOverrideSpellPowerByAP() ~= nil) then\n        text = text .. format(\" (DPS +%s, SP +%s)\",\n            damageBonus,\n            BreakUpLargeNumbers(effectiveAP * GetOverrideSpellPowerByAP() + 0.5)\n        )\n    else\n        text = text .. format(\" (DPS +%s)\", damageBonus)\n    end\n    \n    addStat(lines, tag, text)\nend\n\n-- Attack Speed\nlocal function addAttackSpeed(lines, unit)\n    local meleeHaste = GetMeleeHaste();\n    local speed, offhandSpeed = UnitAttackSpeed(unit);\n    if offhandSpeed then\n        addFStat(lines, \"Attack Speed\", \"%s / %s (Haste +%s%%)\",\n            BreakUpLargeNumbers(speed),\n            BreakUpLargeNumbers(offhandSpeed),\n            BreakUpLargeNumbers(meleeHaste))\n    else\n        addFStat(lines, \"Attack Speed\", \"%s (Haste +%s%%)\",\n            BreakUpLargeNumbers(speed),\n            BreakUpLargeNumbers(meleeHaste))\n    end\nend\n\n-- Power Regen (Energy/Focus)\nlocal function addPowerRegen(lines, unit)\n    if unit ~= \"player\" then return end\n    local powerType, powerToken = UnitPowerType(unit);\n    if powerToken == \"ENERGY\" or powerToken == \"FOCUS\" then\n        local regenRate = GetPowerRegen()\n        addStat(lines, _G[powerToken] .. \" Regen\",\n            BreakUpLargeNumbers(regenRate))\n    end\nend\n\n-- Rune Regen\nlocal function addRuneRegen(lines, unit)\n    if not (unit == \"player\" and select(2, UnitClass(unit)) == \"DEATHKNIGHT\") then\n        return\n    end\n    local _, regenRate = GetRuneCooldown(1); -- Assuming they are all the same for now\n    addStat(lines, \"Rune Speed\", BreakUpLargeNumbers(regenRate) .. \"s\")\nend\n\n-- Spell Power\nlocal function addSpellPower(lines, unit)\n    local minModifier = 0\n    \n    if (unit == \"player\") then\n        local holySchool = 2;\n        -- Start at 2 to skip physical damage\n        minModifier = GetSpellBonusDamage(holySchool);\n        \n        for i=(holySchool+1), MAX_SPELL_SCHOOLS do\n            local bonusDamage = GetSpellBonusDamage(i);\n            minModifier = min(minModifier, bonusDamage);\n        end\n    elseif (unit == \"pet\") then\n        minModifier = GetPetSpellBonusDamage();\n    end\n    \n    addStat(lines, \"Spell Power\", BreakUpLargeNumbers(minModifier))\nend\n\n-- Mana Regen\nlocal function addManaRegen(lines, unit)\n    if unit ~= \"player\" then return end\n    if UnitHasMana(unit) then\n        local base, combat = GetManaRegen();\n        -- All mana regen stats are displayed as mana/5 sec.\n        base = BreakUpLargeNumbers(floor( base * 5.0 ));\n        combat = BreakUpLargeNumbers(floor( combat * 5.0 ));\n        \n        addFStat(lines, \"Mana Regen\", \"%s (Noncombat %s)\", combat, base)\n    else\n        addStat(lines, \"Mana Regen\", \"N/A\")\n    end\nend\n\n-- Armor\nlocal function addArmor(lines, unit)\n    local baselineArmor, effectiveArmor, armor, posBuff, negBuff = UnitArmor(unit)\n    local bonusArmor = UnitBonusArmor(unit);\n    local nonBonusArmor = effectiveArmor - bonusArmor;\n    \n    if ( nonBonusArmor < baselineArmor) then\n        baselineArmor = nonBonusArmor\n    end\n    \n    local level = UnitEffectiveLevel(unit)\n    local baseArmorReduction = GetArmorEffectiveness(baselineArmor, level) * 100;\n    local armorReduction = GetArmorEffectiveness(effectiveArmor, level) * 100;\n    \n    local baseString = \"\"\n    if baseArmorReduction ~= armorReduction then\n        baseString = format(\" (Base %.2f%%)\", baseArmorReduction)\n    end\n    local petString = \"\"\n    if unit == \"player\" then\n        local petBonus = ComputePetBonus(\"PET_BONUS_ARMOR\", effectiveArmor)\n        if petBonus > 0 then\n            petString = format(\" (Pet +%s)\", BreakUpLargeNumbers(floor(petBonus)))\n        end\n    end\n    addFStat(lines, \"Armor\", \"%s / %.2f%%%s%s\",\n        BreakUpLargeNumbers(effectiveArmor),\n        armorReduction,\n        baseString,\n    petString)\nend\n\n-- Dodge\nlocal function addDodge(lines, unit)\n    if unit ~= \"player\" then return end\n    addRatingStat(lines, \"Dodge\", GetDodgeChance(), CR_DODGE)\nend\n\n-- Parry\nlocal function addParry(lines, unit)\n    if unit ~= \"player\" then return end\n    addRatingStat(lines, \"Parry\", GetParryChance(), CR_PARRY)\nend\n\n-- Block\nlocal function addBlock(lines, unit)\n    if unit ~= \"player\" then return end\n    local text = format(\"%s (Stops %d%%)\",\n        formatRatingStat(GetBlockChance(), CR_BLOCK),\n        GetShieldBlock())\n    addStat(lines, \"Block\", text)\nend\n\n-- Main function that calls the individual stat getters.\n-- Obtain all the stats and build a formatted string.\nlocal function makeStatsString(unit)\n    -- Clear all lines\n    wipe(lines)\n    \n    -- Category: General\n    addHeader(lines, \"General\")\n    addHealth(lines, unit)\n    addPower(lines, unit)\n    addItemLevel(lines, unit)\n    addMovementSpeed(lines, unit)\n    \n    -- Category: Primary Stats\n    if unit == \"player\" then\n        addHeader(lines, \"Primary Stats\")\n        addPrimaryStat(lines, unit, LE_UNIT_STAT_STRENGTH)\n        addPrimaryStat(lines, unit, LE_UNIT_STAT_AGILITY)\n        addPrimaryStat(lines, unit, LE_UNIT_STAT_INTELLECT)\n        addPrimaryStat(lines, unit, LE_UNIT_STAT_STAMINA)\n    end\n    \n    -- Category: Secondary Stats\n    if unit == \"player\" then\n        addHeader(lines, \"Secondary Stats\")\n        addCrit(lines, unit)\n        addHaste(lines, unit)\n        addMastery(lines, unit)\n        addVersatility(lines, unit)\n    end\n    \n    -- Category: Tertiary Stats\n    if unit == \"player\" then\n        addHeader(lines, \"Tertiary Stats\")\n        addLifesteal(lines, unit)\n        addAvoidance(lines, unit)\n        addSpeed(lines, unit)\n    end\n    \n    -- Category: Attack\n    addHeader(lines, \"Attack\")\n    addAttackDamage(lines, unit)\n    addAttackPower(lines, unit)\n    addAttackSpeed(lines, unit)\n    addPowerRegen(lines, unit)\n    addRuneRegen(lines, unit)\n    \n    -- Category: Spell\n    addHeader(lines, \"Spell\")\n    addSpellPower(lines, unit)\n    addManaRegen(lines, unit)\n    \n    -- Category: Defense\n    addHeader(lines, \"Defense\")\n    addArmor(lines, unit)\n    addDodge(lines, unit)\n    addParry(lines, unit)\n    addBlock(lines, unit)\n    \n    -- Concatenate the lines, return the result\n    return table.concat(lines, \"\\n\")\nend\n\n----- Display and main loop -----\n\n-- Background\nR.bg = R.bg or R:CreateTexture(\"LegionStatsPaneBg\", \"BACKGROUND\")\nR.bg:SetTexture(\"Interface\\\\AddOns\\\\WeakAuras\\\\Media\\\\Textures\\\\Square_White\")\nR.bg:ClearAllPoints()\nR.bg:SetVertexColor(unpack(bgColor))\nR.bg:SetPoint(\"BOTTOMLEFT\", R, \"BOTTOMLEFT\", -2, -3)\nR.bg:SetPoint(\"TOPRIGHT\", R, \"TOPRIGHT\", -1, 0)\nR.bg:Show()\n\n-- Custom text\nlocal lastRefresh = 0\nlocal refreshInterval = 1/refreshRate\nlocal customText = \"\"\n\n-- Return a new custom text string\nlocal function makeCustomText()\n    -- Normally I'd make the pet stats appear when you're viewing\n    -- the pet stats pane, but they removed it for Legion.\n    -- So pet stats will also appear when you're targeting your pet.\n    if UnitIsUnit(\"target\", \"pet\") then\n        return makeStatsString(\"pet\")\n    else\n        return makeStatsString(\"player\")\n    end\nend\n\nlocal function refreshText()\n    lastRefresh = GetTime()\n    customText = makeCustomText()\nend\n\n-- Positioning and visibility\n\n-- Hack to prevent WeakAuras itself from moving the frame\nR.allowMove = (anchorBehavior == ANCHOR_FIXED)\n\nR.shouldShow = CharacterStatsPane and CharacterStatsPane:IsVisible()\n\n-- Anchor the WeakAura according to anchorBehavior\nlocal function doAnchor()\n    if anchorBehavior == ANCHOR_FIXED then\n        -- No auto-anchoring\n        return\n    elseif anchorBehavior == ANCHOR_RIGHT then\n        -- Anchors the text display to the right of the character frame,\n        -- and flush with the top.\n        if not CharacterFrame then return end\n        R.allowMove = true\n        R:ClearAllPoints()\n        R:SetPoint(\"TOPLEFT\", CharacterFrame, \"TOPRIGHT\", 0, 0)\n        R.allowMove = false\n    elseif anchorBehavior == ANCHOR_OVERLAY then\n        -- Anchors the text display in front of the Blizzard stats pane\n        -- by anchoring the top left corners.\n        if not CharacterFrameInsetRight then return end\n        R.allowMove = true\n        R:SetParent(CharacterFrameInsetRight)\n        R:ClearAllPoints()\n        R:SetPoint(\"TOPLEFT\", CharacterStatsPane, \"TOPLEFT\", 0, 0)\n        R.allowMove = false\n    end\nend\n\nfunction A.onUpdateTrigger()\n    if R.shouldShow then\n        if GetTime() - lastRefresh > refreshInterval then\n            refreshText()\n        end\n    end\n    return R.shouldShow\nend\n\nfunction A.doCustomText()\n    return customText\nend\n\n-- Set up hooks\n\nR.hooks = {}\n\nfunction R.hooks.CharacterStatsPane_OnShow()\n    R.shouldShow = true\nend\n\nfunction R.hooks.CharacterStatsPane_OnHide()\n    R.shouldShow = false\nend\n\nfunction R.hooks.R_OnShow()\n    if anchorBehavior == ANCHOR_OVERLAY then\n        CharacterStatsPane:SetAlpha(0)\n    end\n    refreshText()\n    doAnchor()\nend\n\nfunction R.hooks.R_OnHide()\n    if anchorBehavior == ANCHOR_OVERLAY then\n        CharacterStatsPane:SetAlpha(1)\n    end\nend\n\nfunction R.hooks.R_ClearAllPoints(...)\n    if R.allowMove then\n        R.originals.R_ClearAllPoints(...)\n    end\nend\n\nfunction R.hooks.R_SetPoint(...)\n    if R.allowMove then\n        R.originals.R_SetPoint(...)\n    end\nend\n\nfunction R.hooks.R_SetParent(...)\n	if R.allowMove then\n		R.originals.R_SetParent(...)\n	end\nend\n\nlocal function hookStub(name)\n    return function(...)\n        local f = R.hooks[name]\n        if type(f) ~= \"function\" then\n            errorf('%s: R.hooks[\"%s\"] is %s', A.id, tostring(name), tostring(f))\n        end\n        f(...)\n    end\nend\n\nif not R.hooked then\n    R.originals = {\n        R_ClearAllPoints = R.ClearAllPoints,\n        R_SetPoint = R.SetPoint,\n        R_SetParent = R.SetParent\n    }\n    CharacterStatsPane:HookScript(\"OnShow\", hookStub(\"CharacterStatsPane_OnShow\"))\n    CharacterStatsPane:HookScript(\"OnHide\", hookStub(\"CharacterStatsPane_OnHide\"))\n    R:HookScript(\"OnShow\", hookStub(\"R_OnShow\"))\n    R:HookScript(\"OnHide\", hookStub(\"R_OnHide\"))\n    R.ClearAllPoints = hookStub(\"R_ClearAllPoints\")\n    R.SetPoint = hookStub(\"R_SetPoint\")\n    R.SetParent = hookStub(\"R_SetParent\")\n    R.hooked = true\n    \n    R.hooks.R_OnShow()\nend",
        do_custom = true
      }
    },
    anchorPoint = "BOTTOMLEFT",
    customText = "function()\n    return aura_env.doCustomText()\nend",
    desc = "Arc v0.6 2017-07-08",
    displayText = "%c",
    font = "Arial Narrow",
    fontSize = 14,
    frameStrata = 4,
    height = 447.99993896484375,
    id = "Legion Stats Pane",
    numTriggers = 1,
    regionType = "text",
    selfPoint = "TOPLEFT",
    trigger = {
      check = "update",
      custom = "function() return aura_env.onUpdateTrigger() end",
      custom_type = "status",
      event = "Conditions",
      type = "custom",
      unevent = "auto",
      use_unit = true
    },
    untrigger = {
      custom = "function() return true end"
    },
    width = 277.00003051757813,
    xOffset = 352,
    yOffset = 900.99993896484398
  },
  m = "d",
  s = "2.2.1.4",
  v = 1421
}
